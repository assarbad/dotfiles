#!/usr/bin/env bash
# vim: set autoindent smartindent ts=4 sw=4 sts=4 noet filetype=sh:
[[ $UID -eq 0 ]] || { echo "ERROR: must be run as root."; exit 1; }
pushd $(dirname $0) 2>&1 > /dev/null && BASEDIR=$(pwd) && popd 2>&1 > /dev/null
[[ -t 1 ]] && { cG="\e[1;32m"; cR="\e[1;31m"; cB="\e[1;34m"; cW="\e[1;37m"; cY="\e[1;33m"; cG_="\e[0;32m"; cR_="\e[0;31m"; cB_="\e[0;34m"; cW_="\e[0;37m"; cY_="\e[0;33m"; cZ="\e[0m"; export cR cG cB cY cW cR_ cG_ cB_ cY_ cW_ cZ; }

function clean_debian_derived
{
	PRUNE="$BASEDIR/.bashrc.d/prune-kernels"
	[[ -f "$PRUNE" ]] || { echo "ERROR: this script must sit inside the working copy of an bitbucket.org/assarbad/dotfiles clone."; exit 1; }
	source "$PRUNE" || { echo "ERROR: could not include (source) '$PRUNE'."; exit 1; }
	type prune-kernels 2>&1 > /dev/null || { echo "ERROR: callable 'prune-kernels' does not exist."; exit 1; }
	echo -e "${cW}INFO:${cZ} running ${cG}prune-kernels${cZ}"
	prune-kernels --old
	echo -e "${cW}INFO:${cZ} asking apt-get to purge previously removed packages"
	apt-get --purge remove $(dpkg -l|awk '$1 ~ /^rc/ && $2 ~ /^linux-(headers|image)/ {print $2}')
	echo -e "${cW}INFO:${cZ} asking apt-get to purge and autoremove any no longer needed packages"
	apt-get --purge autoremove
	echo -e "${cW}INFO:${cZ} asking apt-get to purge ${cW}popularity-contest${cZ} and/or ${cW}unattended-upgrades${cZ} if installed"
	apt-get --purge autoremove $(dpkg -l|grep -E '(popularity-contest|unattended-upgrades)'|awk '{print $2}')
	echo -e "${cW}INFO:${cZ} running ${cG}apt-get -y autoclean${cZ}"
	apt-get -y autoclean
	echo -e "${cW}INFO:${cZ} running ${cG}apt-get -y clean${cZ}"
	apt-get -y clean
	echo -e "${cW}INFO:${cZ} removing binary cache files (they will be generated by the next run of ${cW}apt-get update${cZ})"
	rm -f /var/cache/apt/srcpkgcache.bin /var/cache/apt/pkgcache.bin
	if type localepurge > /dev/null 2>&1; then
		echo -e "${cW}INFO:${cZ} running ${cG}localepurge${cZ}"
		localepurge
	fi
	for i in /etc/.pwd.lock /var/log/*.{0..9} /var/log/*.{0..9}.gz /var/cache/apt/archives/partial/* /var/cache/debconf/*.dat-old; do
		if [[ -e "$i" ]]; then
			echo -e "${cW}INFO:${cZ} removing ${cW}$i${cZ}"
			rm -f "$i"
		fi
	done
	find /etc -type f -name '*.dpkg-old' -delete
}

function unsupported
{
	echo -e "${cR}ERROR:${cZ} this script expects a Debian or Debian-derived Linux system or FreeBSD."
	exit 1
}

case $(uname -s) in
	Linux)
		[[ -e "/etc/debian_version" ]] || unsupported
		clean_debian_derived
		;;
	FreeBSD)
		# no special steps, yet!
		;;
	*)
		unsupported
		;;
esac
ZEROFILE="/zerofile"
if [[ -r /etc/fstab ]]; then
	SWAP=$(awk '$3 ~ /^swap/ {print $1}' /etc/fstab)
fi

echo -e "${cW}INFO:${cZ} turning swap off"
swapoff -a

for sw in $SWAP; do
	case $sw in
		UUID=*)
			UUID=${sw#UUID=}
			sw=$(readlink -f /dev/disk/by-uuid/$UUID)
			if [[ -b "$sw" ]]; then
				echo -e "${cW}INFO:${cZ} zeroing swap partition ($sw == $UUID)"
				dd if=/dev/zero of=$sw bs=10M
				[[ "Linux" == "$(uname -s)" ]] && mkswap -U $UUID "$sw"
			fi
			;;
		/dev/*)
			if [[ -b "$sw" ]]; then
				echo -e "${cW}INFO:${cZ} zeroing swap partition ($sw)"
				dd if=/dev/zero of=$sw bs=10M
				[[ "Linux" == "$(uname -s)" ]] && mkswap "$sw"
			fi
			;;
		*)
			echo -e "${cY}WARNING:${cZ} don't know how to handle '$sw' swap space. Skipping."
			;;
	esac
done

trap 'rm -f "$ZEROFILE"; trap - INT TERM EXIT; exit $?' INT TERM EXIT
echo -e "${cW}INFO:${cZ} zero-filling free space on root"
dd if=/dev/zero of=$ZEROFILE bs=10M
echo -e "${cW}INFO:${cZ} synchronizing disks"
sync
echo -e "${cW}PLEASE${cZ} reboot now."
