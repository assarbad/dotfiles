#!/usr/bin/env bash
# vim: set autoindent smartindent ts=4 sw=4 sts=4 noet filetype=sh:
[[ $UID -eq 0 ]] || { echo "ERROR: must be run as root."; exit 1; }
pushd $(dirname $0) 2>&1 > /dev/null && BASEDIR=$(pwd) && popd 2>&1 > /dev/null
[[ -t 1 ]] && { cG="\033[1;32m"; cR="\033[1;31m"; cB="\033[1;34m"; cW="\033[1;37m"; cY="\033[1;33m"; cG_="\033[0;32m"; cR_="\033[0;31m"; cB_="\033[0;34m"; cW_="\033[0;37m"; cY_="\033[0;33m"; cZ="\033[0m"; export cR cG cB cY cW cR_ cG_ cB_ cY_ cW_ cZ; }
ZEROFILE="/zerofile"

function clean_debian_derived
{
	PRUNE="$BASEDIR/.bashrc.d/prune-kernels"
	[[ -f "$PRUNE" ]] || { echo "ERROR: this script must sit inside the working copy of an bitbucket.org/assarbad/dotfiles clone."; exit 1; }
	source "$PRUNE" || { echo "ERROR: could not include (source) '$PRUNE'."; exit 1; }
	type prune-kernels 2>&1 > /dev/null || { echo "ERROR: callable 'prune-kernels' does not exist."; exit 1; }
	echo -e "${cW}INFO:${cZ} running ${cG}prune-kernels${cZ}"
	prune-kernels --old
	echo -e "${cW}INFO:${cZ} asking apt-get to purge previously removed packages"
	apt-get --purge remove $(dpkg -l|awk '$1 ~ /^rc/ && $2 ~ /^linux-(headers|image)/ {print $2}')
	echo -e "${cW}INFO:${cZ} asking apt-get to purge and autoremove any no longer needed packages"
	apt-get --purge autoremove
	echo -e "${cW}INFO:${cZ} asking apt-get to purge ${cW}popularity-contest${cZ} and/or ${cW}unattended-upgrades${cZ} if installed"
	apt-get --purge autoremove $(dpkg -l|grep -E '(popularity-contest|unattended-upgrades)'|awk '{print $2}')
	echo -e "${cW}INFO:${cZ} running ${cG}apt-get -y autoclean${cZ}"
	apt-get -y autoclean
	echo -e "${cW}INFO:${cZ} running ${cG}apt-get -y clean${cZ}"
	apt-get -y clean
	echo -e "${cW}INFO:${cZ} removing binary cache files (they will be generated by the next run of ${cW}apt-get update${cZ})"
	rm -f /var/cache/apt/srcpkgcache.bin /var/cache/apt/pkgcache.bin
	if type localepurge > /dev/null 2>&1; then
		echo -e "${cW}INFO:${cZ} running ${cG}localepurge${cZ}"
		localepurge
	fi
	for i in /etc/.pwd.lock /var/log/*.{0..9} /var/log/*.{0..9}.gz /var/cache/apt/archives/partial/* /var/cache/debconf/*.dat-old; do
		if [[ -e "$i" ]]; then
			echo -e "${cW}INFO:${cZ} removing ${cW}$i${cZ}"
			rm -f "$i"
		fi
	done
	find /etc -type f -name '*.dpkg-old' -delete
}

function clean_freebsd
{
	if type pkg > /dev/null 2>&1; then
		pkg clean
	fi
	echo -e "${cW}INFO:${cZ} removing portsnap, freebsd-update and pkg caches"
	rm -drf /boot/kernel.old /var/db/freebsd-update/install.* /usr/ports/*
	rm -f /var/db/freebsd-update/*-rollback
	rm -f /var/db/portsnap/INDEX /usr/ports/.portsnap.INDEX
	rm -f /usr/ports/INDEX-* /usr/ports/MOVED
	rm -f /var/db/pkg/*.sqlite
	rm -f /var/log/bsdinstall_log /var/log/messages.*.bz2 /var/log/sendmail.st.*
	rm -f /var/cache/pkg/*
	find /var/db/portsnap/files -type f -delete
	find /var/db/freebsd-update/files -type f -delete
	find /var/cache/pkg -type f -name '*.txz' -delete
	mount -t ufs|awk '$3 !~ /^\/$/ {print $3}'|while read mountpt; do
		( \
			set -x; \
			trap 'rm -f "'$mountpt$ZEROFILE'"; trap - INT TERM EXIT; exit $?' INT TERM EXIT; \
			dd if=/dev/zero of=$mountpt$ZEROFILE bs=1M; \
		)
	done
	if mount -t zfs | grep -q zfs; then
		echo -e "${cW}INFO:${cZ} checking for ZFS pools"
		mount -t zfs|awk '$1 ~ /^'$(zpool list -pH|cut -f 1)'$/ {print $3}'|while read mountpt; do
			( \
				set -x; \
				trap 'rm -f "'$mountpt$ZEROFILE'"; trap - INT TERM EXIT; exit $?' INT TERM EXIT; \
				dd if=/dev/zero of=$mountpt$ZEROFILE bs=1M; \
			)
		done
	fi
}

function zerofill_swap
{
	local DEVNAME="$1"
	local UUID="$2"
	local SWTYPE="space"
	[[ -f "$DEVNAME" ]] && SWTYPE="file"
	[[ -b "$DEVNAME" ]] && SWTYPE="partition"

	# Do we need to determine the UUID first?
	if [[ -z "$UUID" ]]; then
		type blkid > /dev/null 2>&1 && local SWAPDETAILS=$(blkid -o export "$DEVNAME" 2> /dev/null|sed 's/^/local /')
		[[ -n "$SWAPDETAILS" ]] && eval "$SWAPDETAILS"
	fi

	# Record the UUID in a form we can present to the user
	if [[ -n "$UUID" ]]; then
		SWUUID="$UUID"
	else
		SWUUID="<unknown>"
	fi
	echo -e "${cW}INFO:${cZ} zero-filling swap $SWTYPE ($DEVNAME == $SWUUID)"

	if [[ "Linux" == "$(uname -s)" ]]; then
		local SWAPSIZE=$(stat -c %s "$DEVNAME")
		if [[ -b "$DEVNAME" ]]; then
			(set -x; dd if=/dev/zero of=$DEVNAME bs=10M)
		elif [[ -f "$DEVNAME" ]]; then
			if ((SWAPSIZE > 0)); then
				local SWZISEINMIB=$((SWAPSIZE / 1024 / 1024))
				echo -e "\tDetermined old size as $SWAPSIZE Bytes == $SWZISEINMIB MiB." 
				(set -x; dd if=/dev/zero of=$DEVNAME bs=1M count=$SWZISEINMIB)
			else
				echo -e "${cY}WARNING:${cZ} existing swap $SWTYPE has zero size. Cannot proceed."
				return
			fi
			chmod 600 "$DEVNAME"
		fi
		if [[ -n "$UUID" ]]; then
			(set -x; mkswap -L SWAP -U $UUID "$DEVNAME")
		else
			(set -x; mkswap -L SWAP "$DEVNAME")
		fi
	elif [[ "FreeBSD" == "$(uname -s)" ]]; then 
		(set -x; dd if=/dev/zero of=$DEVNAME bs=10M)
	else
		echo -e "${cY}WARNING:${cZ} no support for zero-filling swap $SWTYPE on $(uname -s)."
		return
	fi
}

function unsupported
{
	echo -e "${cR}ERROR:${cZ} this script expects a Debian or Debian-derived Linux system or FreeBSD."
	exit 1
}

case $(uname -s) in
	Linux)
		[[ -e "/etc/debian_version" ]] || unsupported
		clean_debian_derived
		;;
	FreeBSD)
		clean_freebsd
		;;
	*)
		unsupported
		;;
esac
if [[ -r /etc/fstab ]]; then
	SWAP=$(awk '$3 ~ /^swap/ {print $1}' /etc/fstab)
fi

echo -e "${cW}INFO:${cZ} turning swap off"
swapoff -a
rm -rf /tmp/ssh-* /tmp/tmux-*

for sw in $SWAP; do
	case $sw in
		UUID=*)
			UUID=${sw#UUID=}
			sw=$(readlink -f /dev/disk/by-uuid/$UUID)
			zerofill_swap "$sw" "$UUID"
			;;
		/*)
			zerofill_swap "$sw" ""
			;;
		*)
			echo -e "${cY}WARNING:${cZ} don't know how to handle '$sw' swap space. Skipping."
			;;
	esac
done

exit 0

echo -e "${cW}INFO:${cZ} zero-filling free space on root"
( set -x; trap 'rm -f "'$ZEROFILE'"; trap - INT TERM EXIT; exit $?' INT TERM EXIT; dd if=/dev/zero of=$ZEROFILE bs=10M; )
echo -e "${cW}INFO:${cZ} synchronizing disks"
sync
echo -e "${cW}PLEASE${cZ} reboot now."
