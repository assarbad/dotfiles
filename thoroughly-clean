#!/usr/bin/env bash
# vim: set autoindent smartindent ts=4 sw=4 sts=4 noet filetype=sh:
[[ $UID -eq 0 ]] || { echo "ERROR: must be run as root."; exit 1; }
pushd $(dirname $0) 2>&1 > /dev/null && BASEDIR=$(pwd) && popd 2>&1 > /dev/null
[[ -t 1 ]] && { cG="\033[1;32m"; cR="\033[1;31m"; cB="\033[1;34m"; cW="\033[1;37m"; cY="\033[1;33m"; cG_="\033[0;32m"; cR_="\033[0;31m"; cB_="\033[0;34m"; cW_="\033[0;37m"; cY_="\033[0;33m"; cZ="\033[0m"; export cR cG cB cY cW cR_ cG_ cB_ cY_ cW_ cZ; }
ZEROFILE="/zerofile"

function clean_debian_derived
{
	PRUNE="$BASEDIR/.bashrc.d/prune-kernels"
	[[ -f "$PRUNE" ]] || { echo "ERROR: this script must sit inside the working copy of an bitbucket.org/assarbad/dotfiles clone."; exit 1; }
	source "$PRUNE" || { echo "ERROR: could not include (source) '$PRUNE'."; exit 1; }
	type prune-kernels 2>&1 > /dev/null || { echo "ERROR: callable 'prune-kernels' does not exist."; exit 1; }
	echo -e "${cW}INFO:${cZ} running ${cG}prune-kernels${cZ}"
	prune-kernels --old
	echo -e "${cW}INFO:${cZ} asking apt-get to purge previously removed packages"
	apt-get --purge remove $(dpkg -l|awk '$1 ~ /^rc/ && $2 ~ /^linux-(headers|image)/ {print $2}')
	echo -e "${cW}INFO:${cZ} asking apt-get to purge and autoremove any no longer needed packages"
	apt-get --purge autoremove
	echo -e "${cW}INFO:${cZ} asking apt-get to purge ${cW}popularity-contest${cZ} and/or ${cW}unattended-upgrades${cZ} if installed"
	apt-get --purge autoremove $(dpkg -l|grep -E '(popularity-contest|unattended-upgrades)'|awk '{print $2}')
	echo -e "${cW}INFO:${cZ} running ${cG}apt-get -y autoclean${cZ}"
	apt-get -y autoclean
	echo -e "${cW}INFO:${cZ} running ${cG}apt-get -y clean${cZ}"
	apt-get -y clean
	echo -e "${cW}INFO:${cZ} removing binary cache files (they will be generated by the next run of ${cW}apt-get update${cZ})"
	rm -f /var/cache/apt/srcpkgcache.bin /var/cache/apt/pkgcache.bin
	if type localepurge > /dev/null 2>&1; then
		echo -e "${cW}INFO:${cZ} running ${cG}localepurge${cZ}"
		localepurge
	fi
	for i in /etc/.pwd.lock /var/log/*.{0..9} /var/log/*.{0..9}.gz /var/cache/apt/archives/partial/* /var/cache/debconf/*.dat-old; do
		if [[ -e "$i" ]]; then
			echo -e "${cW}INFO:${cZ} removing ${cW}$i${cZ}"
			rm -f "$i"
		fi
	done
	find /etc -type f -name '*.dpkg-old' -delete
}

function clean_freebsd
{
	if type pkg > /dev/null 2>&1; then
		pkg clean
	fi
	echo -e "${cW}INFO:${cZ} removing portsnap, freebsd-update and pkg caches"
	rm -drf /boot/kernel.old /var/db/freebsd-update/install.* /usr/ports/*
	rm -f /var/db/freebsd-update/*-rollback
	rm -f /var/db/portsnap/INDEX /usr/ports/.portsnap.INDEX
	rm -f /usr/ports/INDEX-* /usr/ports/MOVED
	rm -f /var/db/pkg/*.sqlite
	rm -f /var/log/bsdinstall_log /var/log/messages.*.bz2 /var/log/sendmail.st.*
	rm -f /var/cache/pkg/*
	find /var/db/portsnap/files -type f -delete
	find /var/db/freebsd-update/files -type f -delete
	find /var/cache/pkg -type f -name '*.txz' -delete
	mount -t ufs|awk '$3 !~ /^\/$/ {print $3}'|while read mountpt; do
		( \
			set -x; \
			trap 'rm -f "'$mountpt$ZEROFILE'"; trap - INT TERM EXIT; exit $?' INT TERM EXIT; \
			dd if=/dev/zero of=$mountpt$ZEROFILE bs=1M; \
		)
	done
	if mount -t zfs | grep -q zfs; then
		echo -e "${cW}INFO:${cZ} checking for ZFS pools"
		mount -t zfs|awk '$1 ~ /^'$(zpool list -pH|cut -f 1)'$/ {print $3}'|while read mountpt; do
			( \
				set -x; \
				trap 'rm -f "'$mountpt$ZEROFILE'"; trap - INT TERM EXIT; exit $?' INT TERM EXIT; \
				dd if=/dev/zero of=$mountpt$ZEROFILE bs=1M; \
			)
		done
	fi
}

function unsupported
{
	echo -e "${cR}ERROR:${cZ} this script expects a Debian or Debian-derived Linux system or FreeBSD."
	exit 1
}

case $(uname -s) in
	Linux)
		[[ -e "/etc/debian_version" ]] || unsupported
		clean_debian_derived
		;;
	FreeBSD)
		clean_freebsd
		;;
	*)
		unsupported
		;;
esac
if [[ -r /etc/fstab ]]; then
	SWAP=$(awk '$3 ~ /^swap/ {print $1}' /etc/fstab)
fi

echo -e "${cW}INFO:${cZ} turning swap off"
swapoff -a
rm -rf /tmp/ssh-* /tmp/tmux-*

for sw in $SWAP; do
	case $sw in
		UUID=*)
			UUID=${sw#UUID=}
			sw=$(readlink -f /dev/disk/by-uuid/$UUID)
			if [[ -b "$sw" ]]; then
				echo -e "${cW}INFO:${cZ} zeroing swap partition ($sw == $UUID)"
				dd if=/dev/zero of=$sw bs=1M
				[[ "Linux" == "$(uname -s)" ]] && mkswap -U $UUID "$sw"
			else
				echo -e "${cY}WARNING:${cZ} $sw is not a block device."
			fi
			;;
		/dev/*)
			echo -e "${cW}INFO:${cZ} zeroing swap partition ($sw)"
			dd if=/dev/zero of=$sw bs=1M
			[[ "Linux" == "$(uname -s)" ]] && mkswap "$sw"
			;;
		*)
			echo -e "${cY}WARNING:${cZ} don't know how to handle '$sw' swap space. Skipping."
			;;
	esac
done

echo -e "${cW}INFO:${cZ} zero-filling free space on root"
( set -x; trap 'rm -f "'$ZEROFILE'"; trap - INT TERM EXIT; exit $?' INT TERM EXIT; dd if=/dev/zero of=$ZEROFILE bs=1M; )
echo -e "${cW}INFO:${cZ} synchronizing disks"
sync
echo -e "${cW}PLEASE${cZ} reboot now."
