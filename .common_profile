# Oliver's .common_profile (Bash/Zsh) - author: oliver@assarbad.net - may be freely copied, taken apart, put together and what not ...
# vim: set autoindent smartindent ts=4 sw=4 sts=4 filetype=sh:

# If not running interactively, don't do anything
[[ $- == *i* ]] || return

function set_prompt_and_uid
{
	# Because UID is readonly we cannot use the real thing, so let's fake it below ;)
	declare -g MYUID=$UID
	if [[ -v BASH_VERSION ]]; then
		if [[ $MYUID -eq 0 ]]; then
			declare -g PS1='${debian_chroot:+($debian_chroot)}\[\033[1;31m\]${SHLVL:+[$SHLVL] }\u\[\033[1;34m\]@\h\[\033[0m\]:\[\033[1;32m\]\w\[\033[0m\]\$ '
		else
			declare -g PS1='${debian_chroot:+($debian_chroot)}\[\033[01;34m\]${SHLVL:+[$SHLVL] }\u@\h\[\033[00m\]:\[\033[01;32m\]\w\[\033[00m\]\$ '
		fi
	elif [[ -v ZSH_VERSION ]]; then
		declare -g PROMPT='[%L] %F{blue}%n@%m:%2~%f %# '
	fi
	# On Windows the superuser has the UID (RID) 500, make it appear as root
	if [[ -n "$COMSPEC" && $MYUID -eq 500 ]]; then
		MYUID=0
	fi
	readonly MYUID
}

function add_home_bin
{
	if [[ -d "$HOME/bin" ]]; then
		if [[ ":$PATH:" != *":$HOME/bin:"* ]]; then
			PATH=$PATH:$HOME/bin
		fi
	fi
}

function set_remote_timeout
{
	# Superuser will get a timeout for the shell if it's a remote shell via SSH
	if [[ -n "$SSH_TTY" && $EUID -eq 0 ]]; then
		export TMOUT=1800
	fi
}

function clean_path_var
{
	# Remove empty entries

	export PATH=${PATH//::/:}
	if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
		return
	fi

	if [[ $EUID -eq 0 ]]; then
		local NEWPATH='' LASTDIR=''
		IFS=: for dir in "$PATH"; do
			LASTDIR=$dir
			[[ ! -d "$dir" ]] && continue
			if command ls -lLd $dir 2>/dev/null | command grep -q '^d.......w. '; then
				echo -e "\nDirectory $dir in PATH was world-writable, removed it from PATH!!!"
			elif [[ "$NEWPATH" != "$dir" ]]; then
				NEWPATH=$NEWPATH:$dir
			fi
		done
		# Remove the leading colon and export this as the path
		PATH=${NEWPATH:1:${#NEWPATH}}
	fi
	export PATH
}

function set_shell_options
{
	if [[ -v BASH_VERSION ]]; then
		# don't put duplicate lines in the history. See bash(1) for more options
		declare -g HISTCONTROL=erasedups:ignorespace
		declare -g HISTIGNORE="&:ls:ll:l:[bf]g:exit:clear:vim:env:cd:cdf:ccd:pushf:ducks:dux:psaux:lsb:chorme"
		declare -g HISTFILESIZE=3000

		shopt -s autocd > /dev/null 2>&1
		shopt -s checkwinsize > /dev/null 2>&1
		shopt -s cdspell > /dev/null 2>&1
		shopt -s dotglob > /dev/null 2>&1
		shopt -s extglob > /dev/null 2>&1
		shopt -s globskipdots > /dev/null 2>&1
		shopt -s failglob > /dev/null 2>&1
	elif [[ -v ZSH_VERSION ]]; then
		declare -g HISTFILE=~/.zsh_history
		declare -g HISTSIZE=3000
		declare -g SAVEHIST=3000
		declare -g HIST_IGNORE="&:ls:ll:l:[bf]g:exit:clear:vim:env:cd:cdf:ccd:pushf:ducks:dux:psaux:lsb:chorme"
		setopt HIST_IGNORE_SPACE
		setopt autocd beep extendedglob nomatch
	fi
}

function ls_aliases
{
	# Alias definitions for ls. Figure out the feature set ... (GNU vs. others)
	if [[ "$OSTYPE" == "linux-gnu" || "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
		if type -p lsd > /dev/null 2>&1; then
			alias ls='lsd --group-dirs=first'
			alias ll='lsd --group-dirs=first --date "+%F %T" -l'
			alias l='lsd --group-dirs=first --date "+%F %T" -lA'
			alias tree='lsd --tree -l --date="+%F %T" --group-dirs=first --blocks=permission,size,date,name'
		else
			local MYLS_OPTIONS='--color=auto --time-style=long-iso'
			ls $MYLS_OPTIONS . > /dev/null 2>&1 || MYLS_OPTIONS='--color=auto'
			ls $MYLS_OPTIONS . > /dev/null 2>&1 || MYLS_OPTIONS=''
			[[ -n "$MYLS_OPTIONS" ]] && export LS_OPTIONS="$MYLS_OPTIONS"
			alias ls='ls $LS_OPTIONS'
			alias ll='ls $LS_OPTIONS -l'
			alias l='ls $LS_OPTIONS -Al'
		fi
	else
		[[ "$(uname -s)" == "Darwin"  ]] && export CLICOLOR=
		[[ "$(uname -s)" == "FreeBSD" ]] && export CLICOLOR=
		alias ll='ls -l'
		alias l='ls -Al'
	fi
	# color hard links in cyan, but a little darker than soft links
	if [[ -e "/etc/debian_version" ]] && type -p dircolors > /dev/null 2>&1; then
		# ls (from GNU coreutils) misbehaves in that it "succeeds" silently (exit code 0) although LS_COLORS is erroneous ... pain
		# ls: unrecognized prefix: mh
		# ls: unparsable value for LS_COLORS environment variable
		# However, this output doesn't seem to be shown when piping. How useless.
		command dircolors|command grep -q 'hl=' && export LS_COLORS="ln=01;36:hl=00;36"
		command dircolors|command grep -q 'mh=' && export LS_COLORS="ln=01;36:mh=00;36"
	fi
}

function convenience_aliases
{
	ls_aliases
	# Convenience aliases
	alias ..='cd ..'
	alias ...='cd ../..'
	alias ....='cd ../../..'
	alias -- -='cd -'
	if type -p mc > /dev/null 2>&1; then
		alias mc='mc -c'
	fi
	if type -p ps > /dev/null 2>&1; then
		alias psaux='ps awwwux'
	fi
	if type -p nano > /dev/null 2>&1; then
		alias nano='nano -w'
	fi
	if type -p date > /dev/null 2>&1; then
		alias currdate='date +"%Y-%m-%d %H:%M:%S"'
	fi
	if type -p ssh > /dev/null 2>&1; then
		alias ssh='ssh -t'
	fi
	if type -p ssh > /dev/null 2>&1 && type -p find > /dev/null 2>&1 && type -p ls > /dev/null 2>&1; then
		alias list-ssh-sockets='find /tmp/ssh-* -name agent.\* -uid $EUID -exec ls -ahl {} \;'
	fi
	if type -p vim > /dev/null 2>&1 && type -p grep > /dev/null 2>&1; then
		if [[ -f "${BASHRCDIR:-$HOME}/.vimrc" ]]; then
			local VIMRC="-u \"${BASHRCDIR:-$HOME}/.vimrc\""
		fi
		if (vim --help 2> /dev/null|grep -q '[[:space:]]*-p'); then
			alias vim="env HOME="${BASHRCDIR:-$HOME}" vim -p -N -n -i NONE${VIMRC:+ $VIMRC}"
		else
			alias vim="env HOME="${BASHRCDIR:-$HOME}" vim -N -n -i NONE${VIMRC:+ $VIMRC}"
		fi
	fi
	if type -p sudo > /dev/null 2>&1; then
		# beroot so we feel at home when assuming super-user rights
		if [[ $EUID -eq 0 ]]; then
			function beroot
			{
				echo 'NOP'
			}
		else
			function beroot
			{
				if (($EUID)); then
					if [[ -f ~/.oldstyle-beroot ]]; then
						sudo -E -u root /usr/bin/env BASHRCDIR="$HOME" "$SHELL"
					else
						sudo -E -u root "$SHELL"
					fi
				else
					echo 'NOP'
				fi
			}
		fi
		declare -fgr beroot
	fi
}

function load_ssh_agent
{
	# Load the SSH agent and if it's loaded already, add the default identity
	if \
		type -p ssh-agent > /dev/null 2>&1 && \
		type -p rm > /dev/null 2>&1 && \
		type -p find > /dev/null 2>&1 && \
		type -p ln > /dev/null 2>&1 && \
		[[ -d "$HOME/.ssh" && -w "$HOME/.ssh" ]]
	then
		local LDR USERSOCK SSHAGENT SSHAGENTARGS
		SSHAGENT=$(type -p ssh-agent)
		SSHAGENTARGS="-s"
		USERSOCK="$HOME/.ssh/ssh_auth_sock"
		if [[ -z "$SSH_AUTH_SOCK" ]] && [[ -x "$SSHAGENT" ]]; then
			eval "$($SSHAGENT $SSHAGENTARGS)"
			[[ -n "$SSH_AGENT_PID" ]] && trap "kill $SSH_AGENT_PID" 0
			[[ -h "$USERSOCK" ]] && rm -f "$USERSOCK"
			ln -s "$SSH_AUTH_SOCK" "$USERSOCK"
		elif [[ "$SSH_AUTH_SOCK" == "$USERSOCK" ]] && [[ -h "$SSH_AUTH_SOCK" ]]; then
			echo -n ""
		elif [[ -S "$SSH_AUTH_SOCK" ]]; then
			echo "Using existing socket: '$SSH_AUTH_SOCK'"
			[[ -h "$USERSOCK" ]] && rm -f "$USERSOCK"
			ln -s "$SSH_AUTH_SOCK" "$USERSOCK"
		else
			SSH_AUTH_SOCK=$(find /tmp/ssh-* -type s -name agent.\* -uid $(id -u) 2> /dev/null|head -n 1)
			if [[ -n "$SSH_AUTH_SOCK" ]]; then
				echo "Found existing socket: $SSH_AUTH_SOCK"
				[[ -h "$USERSOCK" ]] && rm -f "$USERSOCK"
				ln -s "$SSH_AUTH_SOCK" "$USERSOCK"
			fi
		fi
		export SSH_AUTH_SOCK="$USERSOCK"
	fi
}

if type -p starship > /dev/null 2>&1; then
	eval "$(starship init bash)"
else
	set_prompt_and_uid
fi
add_home_bin
set_remote_timeout
clean_path_var
set_shell_options
# make less more friendly for non-text input files, see lesspipe(1)
[[ -x /usr/bin/lesspipe ]] && eval "$(lesspipe)"
umask 022
convenience_aliases

if [[ -v BASH_VERSION ]]; then
	# Check for BASHRCDIR variable ...
	[[ -d "${BASHRCDIR:-$HOME}" ]] || BASHRCDIR="$HOME"
	BASHRCDIR=${BASHRCDIR:-$HOME}

	# Global Bash completion definitions
	if [[ $- == *i* ]]; then
		for i in /etc/bash_completion /usr/local/share/bash-completion/bash_completion.sh; do
			[[ -f "$i" ]] && source "$i"
		done
	fi

	# Aliases in the external file overwrite those above.
	[[ -f "$BASHRCDIR/.bash_aliases" ]] && source "$BASHRCDIR/.bash_aliases"

	# Load additional settings
	BASHHOST="${HOSTNAME%%.*}"
	BASHZONE="${HOSTNAME//$BASHHOST/_}"
	BASHSRCDIR="$BASHRCDIR/.bashrc.d"
	if [[ -d "$BASHSRCDIR" ]]; then
		for f in $(find "$BASHSRCDIR" -maxdepth 1 -type f); do
			source "$f"
		done
		if [[ -d "$BASHSRCDIR/$BASHHOST" ]]; then
			for f in $(find "$BASHSRCDIR/$BASHHOST" -maxdepth 1 -type f); do
				source "$f"
			done
		fi
		if [[ -n "$BASHZONE" ]] && [[ -d "$BASHSRCDIR/$BASHZONE" ]]; then
			for f in $(find "$BASHSRCDIR/$BASHZONE" -maxdepth 1 -type f); do
				source "$f"
			done
		fi
	fi
	unset BASHZONE BASHHOST BASHSRCDIR
fi

# Remove local functions up to here
unset -f set_prompt_and_uid add_home_bin set_remote_timeout clean_path_var set_shell_options ls_aliases convenience_aliases

# On Windows we return early
[[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || -n "$COMSPEC" ]] && { unset -f load_ssh_agent; return; }

load_ssh_agent
if type -p stat > /dev/null 2>&1; then
	LDR="$HOME/.ssh/.load"
	if [[ -O "$LDR" && -G "$LDR" && -s "$LDR" ]]; then
		if (( $(stat -c '%a' "$LDR") <= 644 )); then
			source "$LDR"
		fi
	fi
	unset LDR
fi
# Remove local functions
unset -f load_ssh_agent

# FOR NOW
return

if [[ -n "$TMUX" || -n "$TMUX_PANE" ]]; then # are we running inside Tmux already?
	if [[ -n "$TERM" ]]; then
		REPLACE_TERM=${TERM//xterm/screen}
		if type -p toe > /dev/null 2>&1; then
			TOELIST=$( toe -a > /dev/null 2>&1 && echo "toe -a" || echo "toe -h" )
			if ! $TOELIST|grep -q ^$REPLACE_TERM; then
				REPLACE_TERM=
			fi
			unset TOELIST
		fi
	fi
fi
unset MYUID

if [[ -z "$STARSHIP_SESSION_KEY" ]]; then
	# The prompt command will only show the current directory and username if the terminal type is "correct"
	case "$TERM" in
		xterm*|rvxt*|screen*|putty*)
			export PROMPT_COMMAND='echo -ne "\033]0;${debian_chroot:+($debian_chroot)}${USER}@${HOSTNAME}: ${PWD}\007"'
			;;
	esac
fi

[[ -t 1 ]] && { cG="\033[1;32m"; cR="\033[1;31m"; cB="\033[1;34m"; cW="\033[1;37m"; cY="\033[1;33m"; cG_="\033[0;32m"; cR_="\033[0;31m"; cB_="\033[0;34m"; cW_="\033[0;37m"; cY_="\033[0;33m"; cZ="\033[0m"; export cR cG cB cY cW cR_ cG_ cB_ cY_ cW_ cZ; }
if ((SHLVL < 2)); then
	if type -p lsb_release > /dev/null 2>&1; then
		if [[ -n $(lsb_release -sc) ]]; then
			echo -e "${cG_}$(lsb_release -si) $(lsb_release -sr)${cZ} ${cR_}($(lsb_release -sc))${cZ}"
		else
			echo -e "${cG_}$(lsb_release -si) $(lsb_release -sr)${cZ}"
		fi
	else
		echo -e "${cG_}$(uname -s) $(uname -r)${cZ}"
	fi
	cd
fi

type ccd > /dev/null 2>&1 && unset ccd
# create and cd
function ccd()
{
	mkdir -p "$1" && cd "$1"
}
